# -*- coding: utf-8 -*-
"""GSEA_Analysis_Sunehra Sayanhika.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/198mr-ScWpHhTpSbzTFCEzqNfTQYawhxN
"""

# Install BiocManager if it isn't installed
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

# Load BiocManager
library(BiocManager)

if (!("clusterProfiler" %in% installed.packages())) {
  # Install this package if it isn't installed yet
  BiocManager::install("clusterProfiler", update = FALSE)
}

if (!("msigdbr" %in% installed.packages())) {
  # Install this package if it isn't installed yet
  BiocManager::install("msigdbr", update = FALSE)
}

if (!("org.Hs.eg.db" %in% installed.packages())) {
  # Install this package if it isn't installed yet
  BiocManager::install("org.Hs.eg.db", update = FALSE)
}

"""In this analysis, we will be using clusterProfiler package to perform GSEA and the msigdbr package which contains gene sets from the Molecular Signatures Database (MSigDB) already in the tidy format required by clusterProfiler (Subramanian et al. 2005; Liberzon et al. 2011; Yu et al. 2012; Dolgalev 2020).

We will also need the org.Mm.eg.db package to perform gene identifier conversion (Carlson 2019).
"""

# Attach the library
library(clusterProfiler)

# Package that contains MSigDB gene sets in tidy format
library(msigdbr)

# Human annotation package we'll use for gene identifier conversion
library(org.Hs.eg.db)

# We will need this so we can use the pipe: %>%
library(magrittr)

if (!requireNamespace("data.table", quietly = TRUE)) install.packages("data.table")
library(data.table)

"""We will read in the differential expression results we will download from online. These results are from an acute lymphoblastic leukemia (ALL) mouse lymphoid cell model we used for differential expression analysis using DESeq2 (Love et al. 2014). The table contains summary statistics including Ensembl gene IDs, log2 fold change values, and adjusted p-values (FDR in this case). We can identify differentially regulated genes by filtering these results and use this list as input to GSEA."""

# Read in the differential expression results
diff_expr <- fread("/content/finalresults.csv")

# Read in the contents of the differential expression results file
dge_df <- readr::read_csv("/content/finalresults.csv")
dge_df

"""The Molecular Signatures Database (MSigDB) is a resource that contains annotated gene sets that can be used for pathway or gene set analyses (Subramanian et al. 2005; Liberzon et al. 2011). We can use the msigdbr package to access these gene sets in a format compatible with the package we’ll use for analysis, clusterProfiler (Yu et al. 2012; Dolgalev 2020).

The gene sets available directly from MSigDB are applicable to human studies. msigdbr also supports commonly studied model organisms.

Let’s take a look at what organisms the package supports with msigdbr_species().
"""

msigdbr_species()

"""MSigDB contains 8 different gene set collections (Subramanian et al. 2005; Liberzon et al. 2011) that are distinguished by how they are derived (e.g., computationally mined, curated).

In this example, we will use a collection called Hallmark gene sets for GSEA (Liberzon et al. 2015). Here’s an excerpt of the collection description from MSigDB:

Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying gene set overlaps and retaining genes that display coordinate expression. The hallmarks reduce noise and redundancy and provide a better delineated biological space for GSEA.

Notably, there are only 50 gene sets included in this collection. The fewer gene sets we test, the lower our multiple hypothesis testing burden.

The data we’re interested in here comes from mouse samples, so we can obtain only the Hallmarks gene sets relevant to M. musculus by specifying category = "H" and species = "Mus musculus", respectively, to the msigdbr() function.
"""

h_hallmark_sets <- msigdbr(
  species = "Homo sapiens", # Replace with species name relevant to your data
  category = "H"
)

"""Let’s preview what’s in mm_hallmark_sets."""

head(h_hallmark_sets)

"""Looks like we have a data frame of gene sets with associated gene symbols and Entrez IDs.

In our differential expression results data frame, dge_df we have Ensembl gene identifiers. So we will need to convert our Ensembl IDs into either gene symbols or Entrez IDs for GSEA.

The annotation package org.Mm.eg.db contains information for different identifiers (Carlson 2019). org.Mm.eg.db is specific to Mus musculus – this is what the Mm in the package name is referencing.

We can see what types of IDs are available to us in an annotation package with keytypes().


"""

keytypes(org.Hs.eg.db)

dge_df.testForValidKeys(x, keys, keytype, fks)

"""Even though we’ll use this package to convert from Ensembl gene IDs (ENSEMBL) to gene symbols (SYMBOL), we could just as easily use it to convert to and from any of these keytypes() listed above.

The function we will use to map from Ensembl gene IDs to gene symbols is called mapIds() and comes from the AnnotationDbi.

Let’s create a data frame that shows the mapped gene symbols along with the differential expression stats for the respective Ensembl IDs.
"""

# First let's create a mapped data frame we can join to the differential
# expression stats
dge_mapped_df <- data.frame(
  gene_symbol = mapIds(
    # Replace with annotation package for the organism relevant to your data
    org.Hs.eg.db,
    keys = as.character(dge_df$...1),
    # Replace with the type of gene identifiers in your data
    keytype = "ENSEMBL",
    # Replace with the type of gene identifiers you would like to map to
    column = "SYMBOL",
    # This will keep only the first mapped value for each Ensembl ID
    multiVals = "first"
  )
) %>%
  # If an Ensembl gene identifier doesn't map to a gene symbol, drop that
  # from the data frame
  dplyr::filter(!is.na(gene_symbol)) %>%
  # Make an `Ensembl` column to store the rownames
  tibble::rownames_to_column("Ensembl") %>%
  # Now let's join the rest of the expression data
  dplyr::inner_join(dge_df, by = c("Ensembl" = "...1"))

"""This 1:many mapping between keys and columns message means that some Ensembl gene identifiers map to multiple gene symbols. In this case, it’s also possible that a gene symbol will map to multiple Ensembl IDs. For the purpose of performing GSEA later in this notebook, we keep only the first mapped IDs."""

head(dge_mapped_df)

"""The goal of GSEA is to detect situations where many genes in a gene set change in a coordinated way, even when individual changes are small in magnitude (Subramanian et al. 2005).

GSEA calculates a pathway-level metric, called an enrichment score (sometimes abbreviated as ES), by ranking genes by a gene-level statistic. This score reflects whether or not a gene set or pathway is overrepresented at the top or bottom of the gene rankings (Subramanian et al. 2005; Yu 2020). Specifically, genes are ranked from most positive to most negative based on their statistic and a running sum is calculated by starting with the most highly ranked genes and increasing the score when a gene is in the pathway and decreasing the score when a gene is not. In this example, the enrichment score for a pathway is the running sum’s maximum deviation from zero. GSEA also assesses statistical significance of the scores for each pathway through permutation testing. As a result, each input pathway will have a p-value associated with it that is then corrected for multiple hypothesis testing (Subramanian et al. 2005; Yu 2020).

The implementation of GSEA we use in this examples requires a gene list ordered by some statistic (here we’ll use log2 fold changes calculated as part of differential gene expression analysis) and input gene sets (Hallmark collection). When you use previously computed gene-level statistics with GSEA, it is called GSEA pre-ranked.

The GSEA() function takes a pre-ranked and sorted named vector of statistics, where the names in the vector are gene identifiers. It requires unique gene identifiers to produce the most accurate results, so we will need to resolve any duplicates found in our dataset. (The GSEA() function will throw a warning if we do not do this ahead of time.)

Let’s check to see if we have any gene symbols that mapped to multiple Ensembl IDs.
"""

any(duplicated(dge_mapped_df$gene_symbol))

"""Looks like we do have duplicated gene symbols. Let’s find out which ones.


"""

dup_gene_symbols <- dge_mapped_df %>%
  dplyr::filter(duplicated(gene_symbol)) %>%
  dplyr::pull(gene_symbol)

"""Now let’s take a look at the rows associated with the duplicated gene symbols.


"""

dge_mapped_df %>%
  dplyr::filter(gene_symbol %in% dup_gene_symbols) %>%
  dplyr::arrange(gene_symbol)

"""We can see that the associated values vary for each row.

As we mentioned earlier, we will want to remove duplicated gene identifiers in preparation for the GSEA() step. Let’s keep the Entrez IDs associated with the higher absolute value of the log2 fold change. GSEA relies on genes’ rankings on the basis of a gene-level statistic and the enrichment score that is calculated reflects the degree to which genes in a gene set are overrepresented in the top or bottom of the rankings (Subramanian et al. 2005; Yu 2020).

Retaining the instance of the Entrez ID with the higher absolute value of a gene-level statistic means that we will retain the value that is likely to be more highly- or lowly-ranked or, put another way, the values less likely to be towards the middle of the ranked gene list. We should keep this decision in mind when interpreting our results. For example, if all the duplicate identifiers happened to be in a particular gene set, we may get an overly optimistic view of how perturbed that gene set is because we preferentially selected instances of the identifier that have a higher absolute value of the statistic used for ranking.

We are removing values for 33 out of thousands of genes here, so it is unlikely to have a considerable impact on our results.

In the next chunk, we are going to filter out the duplicated row using the dplyr::distinct() function This will keep the first row with the duplicated value thus keeping the row with the highest absolute value of the log2 fold change.
"""

filtered_dge_mapped_df <- dge_mapped_df %>%
  # Sort so that the highest absolute values of the log2 fold change are at the
  # top
  dplyr::arrange(dplyr::desc(abs(log2FoldChange))) %>%
  # Filter out the duplicated rows using `dplyr::distinct()`
  dplyr::distinct(gene_symbol, .keep_all = TRUE)

"""Note that the log2 fold change estimates we use here have been subject to shrinkage to account for genes with low counts or highly variable counts. See the DESeq2 package vignette for more information on how DESeq2 handles the log2 fold change values with the lfcShrink() function.

Let’s check to see that we removed the duplicate gene symbols and kept the rows with the higher absolute value of the log2 fold change.
"""

any(duplicated(filtered_dge_mapped_df$gene_symbol))

"""Looks like we were able to successfully get rid of the duplicate gene identifiers and keep the observations with the higher absolute value of the log2 fold change!

In the next chunk, we will create a named vector ranked based on the gene-level log2 fold change values.
"""

# Let's create a named vector ranked based on the log2 fold change values
lfc_vector <- filtered_dge_mapped_df$log2FoldChange
names(lfc_vector) <- filtered_dge_mapped_df$gene_symbol

# We need to sort the log2 fold change values in descending order here
lfc_vector <- sort(lfc_vector, decreasing = TRUE)

"""Let’s preview our pre-ranked named vector.


"""

# Look at first entries of the ranked log2 fold change vector
head(lfc_vector)

"""Genes were ranked from most positive to most negative, weighted according to their gene-level statistic, in the previous section. In this section, we will implement GSEA to calculate the enrichment score for each gene set using our pre-ranked gene list.

The GSEA algorithm utilizes random sampling so we are going to set the seed to make our results reproducible.


"""

# Set the seed so our results are reproducible:
set.seed(2020)

"""We can use the GSEA() function to perform GSEA with any generic set of gene sets, but there are several functions for using specific, commonly used gene sets (e.g., gseKEGG()).

Significance is assessed by permuting the gene labels of the pre-ranked gene list and recomputing the enrichment scores of the gene set for the permuted data, which generates a null distribution for the enrichment score. The pAdjustMethod argument to GSEA() above specifies what method to use for adjusting the p-values to account for multiple hypothesis testing; the pvalueCutoff argument tells the function to only return pathways with adjusted p-values less than that threshold in the results slot.
"""

gsea_results <- GSEA(
  geneList = lfc_vector, # Ordered ranked gene list
  minGSSize = 25, # Minimum gene set size
  maxGSSize = 500, # Maximum gene set set
  pvalueCutoff = 0.05, # p-value cutoff
  eps = 0, # Boundary for calculating the p value
  seed = TRUE, # Set seed to make results reproducible
  pAdjustMethod = "BH", # Benjamini-Hochberg correction
  TERM2GENE = dplyr::select(
    h_hallmark_sets,
    gs_name,
    gene_symbol
  )
)

"""Let’s take a look at the table in the result slot of gsea_results.


"""

# We can access the results from our `gsea_results` object using `@result`
head(gsea_results@result)

"""Looks like we have gene sets returned as significant at FDR (false discovery rate) of 0.05. If we did not have results that met the pvalueCutoff condition, this table would be empty. If we wanted all results returned we would need to set the pvalueCutoff = 1.

The NES column contains the normalized enrichment score, which normalizes for the gene set size, for that pathway.

Let’s convert the contents of result into a data frame that we can use for further analysis and write to a file later.
"""

gsea_result_df <- data.frame(gsea_results@result)
gsea_result_df

"""Let’s look at the 3 gene sets with the most positive NES.


"""

gsea_result_df %>%
  # This returns the 3 rows with the largest NES values
  dplyr::slice_max(NES, n = 3)

most_positive_nes_plot <- enrichplot::gseaplot(
  gsea_results,
  geneSetID = "HALLMARK_MYC_TARGETS_V2",
  title = "HALLMARK_MYC_TARGETS_V2",
  color.line = "#0d76ff"
)
most_positive_nes_plot

"""Let’s look for the 3 gene sets with the most negative NES.


"""

gsea_result_df %>%
  # Return the 3 rows with the smallest (most negative) NES values
  dplyr::slice_min(NES, n = 3)

most_negative_nes_plot <- enrichplot::gseaplot(
  gsea_results,
  geneSetID = "HALLMARK_HYPOXIA",
  title = "HALLMARK_HYPOXIA",
  color.line = "#0d76ff"
)
most_negative_nes_plot

readr::write_tsv(
  gsea_result_df,
  file.path(
    "./",
    "GSE171663_gsea_results.tsv"
  )
)

"""Ref: https://alexslemonade.github.io/refinebio-examples/03-rnaseq/pathway-analysis_rnaseq_02_gsea.html"""





